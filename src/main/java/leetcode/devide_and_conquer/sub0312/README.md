# 题目

- Java：[312]戳气球
- Related Topics 数组 动态规划 👍 1133 👎 0

```text
有 n 个气球，编号为0 到 n - 1，
  每个气球上都标有一个数字，
  这些数字存在数组 nums 中。 

现在要求你戳破所有的气球。
  戳破第 i 个气球，
    你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 
  这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。
  如果 i - 1或 i + 1 超出了数组的边界，
  那么就当它是一个数字为 1 的气球。 

求所能获得硬币的最大数量。 


示例 1：

输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167 


示例 2： 

输入：nums = [1,5]
输出：10


提示： 

n == nums.length 
1 <= n <= 300 
0 <= nums[i] <= 100 
```

# 读题

- 戳破 `气球i` 可获得硬币数量为：
  - 当 `n = 1` 时，可得：`1 * nums[i] * 1`
  - 当 `n = 2` 时，可得：`1 * nums[i] * nums[i + 1]`
  - 当 `n > 2` 时，可得：`nums[i - 1] * nums[i] * nums[i + 1]`
- 求戳破所有气球可获得最大的硬币数量

# 法一：动态规划

- 核心：动态规划

## 思路

- 定义一个数组 `dp[n + 2][n + 2]`
  - `dp[i][j]` : 表示 戳破 `(i, j)` 之间的所有气球可获得的最大硬币数量
- 在气球两边分别插入两个虚拟气球：`nums[-1] = nums[n] = 1`
- 开始戳气球，戳破 `(i, j)` 之间的气球可获得的最大硬币数量
  - 最后戳破 `气球k` 时，可获得的最大硬币数量为：
    - `i < k < j`
    - `dp[i][k] + (coins[i] * coins[k] * coins[j]) + dp[k][j]`
      - `dp[i][k]`：戳破 `(i, k)` 之间的气球可获得的最大硬币数量
      - `dp[k][j]`：戳破 `(k, j)` 之间的气球可获得的最大硬币数量
      - `coins[i] * coins[k] * coins[j]`：戳破 `气球k` 时可获得的硬币数量
- 逆向思维推演过程：

```text
# 例子：
             [3, 1, 5, 8]
# 1、在两端，插入虚拟气球
          [1, 3, 1, 5, 8, 1]
# 2、逆向思维，穷举 `(i, j)` 之间的所有方式
## 2.1、假设仅剩最后一个 `气球8`，此时的 i k j 的位置分别为:
    index: 0, 1, 2, 3, 4, 5
                    i  k  j
          [1, 3, 1, 5, 8, 1]
  由于，(i, k) 和 (k, j) 之间不存在气球
  所以，
    dp[i][k] = 0
    dp[k][j] = 0
  最后，
    dp[i][j] = coins[i] * coins[k] * coins[j]
## 2.2、假设仅剩最后两个 `气球5/8`，此时的 i k j 的位置分别为:
  2.2.1、dp[i][k] = 0, dp[k][j] = 0
    index: 0, 1, 2, 3, 4, 5
                 i  k  j
          [1, 3, 1, 5, 8, 1]
    dp[i][j] = coins[i] * coins[k] * coins[j]
  
  2.2.2.1、j 向右移
    index: 0, 1, 2, 3, 4, 5
                 i  k     j
          [1, 3, 1, 5, 8, 1]
    dp[i][j] = dp[k][j] + coins[i] * coins[k] * coins[j]
    其中：dp[k][j] 在 2.1 中已计算
  
  2.2.2.2、k 向右移
    index: 0, 1, 2, 3, 4, 5
                 i     k  j
          [1, 3, 1, 5, 8, 1]
    dp[i][j] = dp[i][k] + coins[i] * coins[k] * coins[j]
    其中：dp[i][k] 在 2.2.1 中已计算
    
  ...
```

## 实现

### 边界问题

- 只有一个气球，返回 `nums[0]`

### 细节问题

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n^2)` | `O(n^2)` + `O(n)` </br> - `O(n^2)` : 存储状态值 </br> - `O(n)` : 存储每个气球对应的硬币数
时间 | `O(n^3)` | `O(n^3)` + `O(n)` </br> - `O(n^3)` : 遍历气球数量 & 气球间的气球数量 </br> - `O(n)` : 遍历气球对应的硬币数

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(n^2)` | `O(n^3)` | - 其他
