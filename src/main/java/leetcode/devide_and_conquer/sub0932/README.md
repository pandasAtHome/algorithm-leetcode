# 题目

- Java：[932]漂亮数组
- Related Topics 数组 数学 分治 👍 191 👎 0

```text
对于某些固定的 N，
  如果数组 A 是整数 1, 2, ..., N 组成的排列，使得： 
    对于每个 i < j，
    都不存在 k 满足 i < k < j 使得 A[k] * 2 = A[i] + A[j]。 
  那么数组 A 是漂亮数组。 
  给定 N，返回任意漂亮数组 A（保证存在一个）。 


示例 1： 

输入：4
输出：[2,1,4,3]


示例 2： 

输入：5
输出：[3,1,2,5,4]


提示： 

1 <= N <= 1000 
```

# 读题

- 给出一个数字 `n`，返回一个长度为 `n` 的漂亮数组 `A`
  - 对于: `i < k < j`
  - 有: `2 * A[k] != A[i] + A[j]`

# 法一：分治

- 核心：分治

## 思路

- 要使: `2 * A[k] != A[i] + A[j]`
  - `A[i]` 为奇数，`A[j]` 为偶数
  - `A[i]` 为偶数，`A[j]` 为奇数

## 实现

### 边界问题

- `n = 1`: `[1]`
- `n = 2`: `[2, 1]`

### 细节问题

- 创建一个 map，记录 `[1, n]` 对应的结果

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n log n)` | `O(log n)` + `O(n)` </br> - `O(n)` : 每个数字n对应的结果 </br> - `O(log n)` : 递归栈空间消耗
时间 | `O(n log n)` | `O(log n)` + `O(n)` </br> - `O(n)` : 遍历奇数&偶数 </br> - `O(log n)` : 递归分治

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(n log n)` | `O(n log n)` | - `n > 2`
