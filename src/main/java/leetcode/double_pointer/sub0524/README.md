# 题目

- Java：[524]通过删除字母匹配到字典里最长单词
- Related Topics 数组 双指针 字符串 排序 👍 312 👎 0

```text
通过删除字母匹配到字典里最长单词
给你一个字符串 s 和一个字符串数组 dictionary ，
  找出并返回 dictionary 中最长的字符串，
  该字符串可以通过删除 s 中的某些字符得到。

如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。 


示例 1： 

输入：s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]
输出："apple"


示例 2： 

输入：s = "abpcplea", dictionary = ["a","b","c"]
输出："a"


提示： 

1 <= s.length <= 1000 
1 <= dictionary.length <= 1000 
1 <= dictionary[i].length <= 1000 
s 和 dictionary[i] 仅由小写英文字母组成 
```

# 读题

- 在一个字符串数组 dictionary 中，找出`长度最长`且`字母序最小`且`存在于另一个字符串 s 中`的元素
- 该元素可通过 删除字符串 s 的某些字符得到

# 法一：双指针 + 排序

- 核心：同向双指针

## 思路

- 对字符串数组，按元素长度倒序
  - 长度大的在前面
  - 长度相同，字母序较小者在前面
- 遍历字符串数组，找出第一个符合条件的元素，即可完成查找

## 实现

### 边界问题

- 退出条件：`元素指针 == 元素长度`

### 细节问题

- 先对字符串数组，按各元素的长度倒序，寻找到`长度最长`且`字母序最小`的元素，即可退出循环
- 可能会多次获取 `搜索的字符串s` 中的元素，转换成字符数组

### [代码实现](Demo01.java)

### 复杂度

- `n = s.length`
- `m = dictionary.length`
- `l = dictionary[i].length`

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(log m)` + `4 * O(1)` + `O(n)` </br> - `O(log m)` : 字符串数组排序 </br> - `O(1)` : 数值变量 </br> - `O(n)` : 字符串转字符数组
时间 | `O(m * (l + n))` | `O(2m + m log m)` + `3 * O(n)` + `5 * O(m)` + `3 * O(l + n)` + `O(3l)` + `3 * O(l + n)` </br> - `O(2m + m log m)` : 字符串数组排序 </br> - `O(n)` : 字符串转字符数组 & 获取字符串字符 & 移动指针 </br> - `O(m)` : 字符串数组遍历 & 3次赋值 & 长度比较 </br> - `O(l + n)` : 循环条件判断 & 字符比较 </br> - `O(3l)` : 获取单词字符

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(n)` | `O(l + n)` | 排序后，第一个单词就是目标
最坏 | `O(n)` | `O(m * (l + n))` | 排序后，最后一个单词就是目标
