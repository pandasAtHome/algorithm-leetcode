# 题目

- Java：[64]最小路径和
- Related Topics 数组 动态规划 矩阵 👍 1371 👎 0

```text
给定一个包含非负整数的 m x n 网格 grid ，
  请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 

说明：每次只能向下或者向右移动一步。 


示例 1： 

输入：grid = [[1,3,1],
             [1,5,1],
             [4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。


示例 2： 

输入：grid = [[1,2,3],[4,5,6]]
输出：12


提示： 

m == grid.length 
n == grid[i].length 
1 <= m, n <= 200 
0 <= grid[i][j] <= 100 
```

# 读题

- 计算从左上角到右下角的最短距离

# 法一：动态规划

- 核心：动态规划

## 思路

- 定义一个列表，用于记录到达当前格子的最短距离
- 初始化第一个格子距离为其本身
- 计算【左边界上的格子距离，由于边界左边没有格子，所以只需累计从上一个到当前格子的距离
- 计算【上边界】上的格子距离，由于边界上边没有格子，所以只需累计从左边一个到当前格子的距离
- 每次只能【向右】或【向下】移动，反向思考，只能从【左】或【上】到达当前格子
- 计算到达中间格子的最短距离
  - 到达当前格子的距离 = 当前格子距离 + min(到达左边格子的最短距离, 到达上边格子的最短距离)

## 实现

### 边界问题

- 对于左边界，只需从上到下累计
- 对于上边界，只需从左到右累计

### 细节问题

- 左上角第一个点，没有来源，达到它的距离为它本身
- 对于左/上边界，只需要计算一个方向，可以单独处理

### [代码实现](/src/main/java/leetcode/sub0064/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(nm)` | `O(nm)` </br> - 记录到达每个格子的最短路径
时间 | `O(nm)` | `O(nm)` </br> - 遍历计算到达每个格子的最短路径

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | 只有一个格子
其次 | `O(n|m)` | `O(n|m)` | 只有一行 或 只有一列
最坏 | `O(nm)` | `O(nm)` | `n * m` 矩阵
