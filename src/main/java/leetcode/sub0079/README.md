# 题目

- Java：[79]单词搜索
- Related Topics 数组 回溯 矩阵 👍 1442 👎 0

```text
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。
     如果 word 存在于网格中，返回 true ；
     否则，返回 false 。 

单词必须按照字母顺序，通过相邻的单元格内的字母构成，
     其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。
     同一个单元格内的字母不允许被重复使用。 


示例 1： 

输入：board = [["A","B","C","E"],
              ["S","F","C","S"],
              ["A","D","E","E"]], 
     word = "ABCCED"
输出：true


示例 2： 

输入：board = [["A","B","C","E"],
              ["S","F","C","S"],
              ["A","D","E","E"]], 
     word = "SEE"
输出：true


示例 3： 

输入：board = [["A","B","C","E"],
              ["S","F","C","S"],
              ["A","D","E","E"]], 
     word = "ABCB"
输出：false


提示： 

m == board.length 
n = board[i].length 
1 <= m, n <= 6 
1 <= word.length <= 15 
board 和 word 仅由大小写英文字母组成 

进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？ 
```

# 读题

- 找出一个单词是否在字符矩阵中
  - 单词必须按照字母顺序
  - 字符间必须相邻（左上右下方位）
  - 矩阵中的每个字符只能用一次

# 法一：回溯法

- 核心：深度优先搜索 + 标记回溯

## 思路

- 获取矩阵大小
- 定义一个矩阵，记录字符是否被使用过
- 字符匹配，组成单词
  - 若 字符不匹配，退出此链路查找；
  - 若 已经找到所有字符，返回结果；
  - 否则，继续匹配下一个字符
- 锁定当前字符
- 遍历向当前字符的四个方位（左上右下）匹配目标
  - 不符合条件：不在矩阵范围内 or 该位置的字符已被使用
  - 满足前置条件：矩阵范围内 and 字符未被使用
- 解锁当前字符
- 返回结果

## 实现

### 边界问题

- 只查找矩阵区间内的字符
  - `0 <= rows < m`
  - `0 <= cols < n`

### 细节问题

- 找到符合条件，即可停止
- 被使用过的字符，提前结束

### [代码实现](/src/main/java/leetcode/sub0079/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(mn)` | `O(1)` + `O(L)` + `O(mn)` </br> - `O(1)` : 数值变量 </br> - `O(L)` : 单词的字符数组 </br> - `O(mn)` : 递归栈空间 & 字符使用记录矩阵
时间 | `O(mn * 3^L)` | `O(mn * 3^L)` </br> - 单词的字符匹配

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(mn)` | `O(1)` | 矩阵只有1个元素，单词只有一个字符
其次 | `O(mn)` | `O(n * 3^L)` | 单词的第一个字符，在矩阵第一行
最差 | `O(mn)` | `O(n * 3^L)` | 单词的第一个字符，不在矩阵第一行
