# 题目

- Java：[34]在排序数组中查找元素的第一个和最后一个位置
- Related Topics 数组 二分查找 👍 1875 👎 0

```text
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。
  请你找出给定目标值在数组中的开始位置和结束位置。 

如果数组中不存在目标值 target，返回 [-1, -1]。 

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 


示例 1： 

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4] 


示例 2： 

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1] 


示例 3： 

输入：nums = [], target = 0
输出：[-1,-1] 


提示： 

0 <= nums.length <= 10⁵ 
-10⁹ <= nums[i] <= 10⁹ 
nums 是一个非递减数组 
-10⁹ <= target <= 10⁹ 
```

# 读题

- 在 `O(log n)` 时间内，在一个 `非递减整数` 数组中寻找一个数字的 `开始` & `结束` 位置

# 法一：二分查找

- 核心：左闭右开，二分查找

## 思路

- 寻找 `开始坐标` = 第一个 `>= target` 的坐标
- 寻找 `结束坐标` = 第一个 `> target` 的坐标 - 1

## 实现

### 边界问题

- 退出条件：`low < high`

### 细节问题

- 空数组
- 数组中，不存在目标值

区间 | start | 结果
:--- |:--- |:---
`target < nums[0]` | `0` | `target > nums[start]`
`nums[0] < target < nums[n-1]` | `x` | `target != nums[start]`
`nums[n-1] < target` | `n` | `index 超出范围`

- 找到 `开始坐标` 后，寻找 `结束坐标` 时，可以使用 `开始坐标` 作为 `起始点`
  - 由于 `开始坐标` 可能为 `0`，所以寻找 `开始坐标` 时，使用 `-1`

### [代码实现](/src/main/java/leetcode/sub0034/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `5 * O(1)` </br> - `O(1)` : 数值变量
时间 | `O(log n)` | `2 * 7 * O(log n)` </br> - `O(log n)` : 2次坐标查询 * (1次数组遍历 + 2次赋值 + 2次计算 + 1次比较 + 1次元素查找)

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | 细节问题1
其次 | `O(1)` | `O(log n)` | 细节问题2
最差 | `O(1)` | `O(log n)` | 目标值在数组中
