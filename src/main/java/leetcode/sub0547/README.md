# 题目

- Java：[547]省份数量
- Related Topics 深度优先搜索 广度优先搜索 并查集 图 👍 870 👎 0

```text
有 n 个城市，其中一些彼此相连，另一些没有相连。
  如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，
  那么城市 a 与城市 c 间接相连。 

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 

给你一个 n x n 的矩阵 isConnected ，
  其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，
  而 isConnected[i][j] = 0 表示二者不直接相连。 

返回矩阵中 省份 的数量。 


示例 1： 

输入：isConnected = [[1,1,0],
                    [1,1,0],
                    [0,0,1]]
输出：2


示例 2： 

输入：isConnected = [[1,0,0],
                    [0,1,0],
                    [0,0,1]]
输出：3


提示： 

1 <= n <= 200 
n == isConnected.length 
n == isConnected[i].length 
isConnected[i][j] 为 1 或 0 
isConnected[i][i] == 1 
isConnected[i][j] == isConnected[j][i] 
```

# 读题

- 有 n 个城市，若 `isConnected[a][b] = 1`，`isConnected[b][c] = 1`，a 与 c 间接相连，a/b/c 在一个省

# 法一：深度优先搜索

- 核心：深度优先搜索 + hash 表

## 思路

- 定义一个浏览记录列表
- 遍历所有城市
- 若当前城市未检索，标记出属于同一省份的所有城市

## 实现

### 边界问题

- 一共 n个 城市

### 细节问题

- 列表中的城市并不是按照同一省份的城市放在一块的
  - 可以跳过浏览过的城市

### [代码实现](/src/main/java/leetcode/sub0547/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 浏览记录列表
时间 | `O(n^2)` | `O(n^2)` </br> - 遍历城市间的联系

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(n)` | `O(1)` | 只有一个城市
最坏 | `O(n)` | `O(n^2)` | 其他情况
