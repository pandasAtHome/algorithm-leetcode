# 题目

- Java：[322]零钱兑换
- Related Topics 广度优先搜索 数组 动态规划 👍 2176 👎 0

```text
给你一个整数数组 coins ，表示不同面额的硬币；
  以及一个整数 amount ，表示总金额。 

计算并返回可以凑成总金额所需的 最少的硬币个数 。
  如果没有任何一种硬币组合能组成总金额，返回 -1 。 

你可以认为每种硬币的数量是无限的。 


示例 1： 

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1 


示例 2： 

输入：coins = [2], amount = 3
输出：-1 


示例 3： 

输入：coins = [1], amount = 0
输出：0


提示： 

1 <= coins.length <= 12 
1 <= coins[i] <= 2³¹ - 1 
0 <= amount <= 10⁴ 
```

# 读题

- 在一个硬币数组中，找出 组成 `amount` 金额所需的最少的硬币数量
  - 每种硬币可重复选取

# 法一：动态规划

- 核心：动态规划（完全背包）

## 思路

- 定义一个数组：记录组成 `[1, amount]` 金额所需要的最少的硬币数量
- 初始化：最多需要 `amount + 1` 个硬币
- 遍历 `[1, amount]` 金额所需要的最少的硬币数量
- 组成 金额为 `amount` 的硬币数量为：
  - 大于 amount 个：无组合
  - 否则，返回硬币数量

## 实现

### 边界问题

- `amount == 0`：需要 0 个硬币
- 只比较 `硬币面值` 小于等于 `当前总金额` 的硬币

### 细节问题

- `dp[0] == 0`：组成 `金额为0` 需要0个硬币

### [代码实现](Demo01.java)

### 复杂度

- `n` : `amount`
- `m` : 硬币的种数

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 记录每个总金额所需的硬币数量
时间 | `O(mn)` | `O(mn)` + `O(n)` </br> - `O(mn)` : 遍历每个总金额 & 所有硬币 </br> - `O(n)` : 初始化 每个总金额 所需的硬币数量

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(n)` | `O(mn)` | - 其他
