# 题目

- Java：[494]目标和
- Related Topics 数组 动态规划 回溯 👍 1426 👎 0

```text
给你一个整数数组 nums 和一个整数 target 。 
  向数组中的每个整数前添加 '+' 或 '-' ，
  然后串联起所有整数，可以构造一个 表达式 ： 
    例如，nums = [2, 1] ，
      可以在 2 之前添加 '+' ，
      在 1 之前添加 '-' ，
      然后串联起来得到表达式 "+2-1" 。 
  返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 


示例 1： 

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3


示例 2： 

输入：nums = [1], target = 1
输出：1


提示： 

1 <= nums.length <= 20 
0 <= nums[i] <= 1000 
0 <= sum(nums[i]) <= 1000 
-1000 <= target <= 1000 
```

# 读题

- 在 `[0, 1000]` 组成的数组中，使用 `+` or `-` 使得元素之和为 `target`

# 法一：动态规划

- 核心：动态规划（0-1背包）

## 思路

- 求和，判断 `sum > target` 是否成立
- 定义一个数组，记录：元素之和 分别等于 `[0, neg]` 的组合个数

## 实现

### 边界问题

- `sum < target` ，无解
- `sum - target` 为基数，无解

### 细节问题

- `sum == target` 只有一种解

### [代码实现](Demo01.java)

### 复杂度

- `sum` : 数组的元素之和
- `target` : 目标数值
- `neg = (sum - target) / 2`

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(neg)` | `O(neg)` </br> - 记录 元素之和分别为 `[0, neg]` 的组合个数
时间 | `O(n * neg)` | `O(n)` + `O(n * neg)` </br> - `O(n)` : 数组求和 </br> - `O(n * neg)` : 求组合数

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(n)` | - 边界问题1 & 边界问题2
最坏 | `O(neg)` | `O(n * neg)` | - 其他
