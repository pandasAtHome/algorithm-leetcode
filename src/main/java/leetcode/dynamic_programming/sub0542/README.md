# 题目

- Java：[542]01 矩阵
- Related Topics 广度优先搜索 数组 动态规划 矩阵 👍 770 👎 0

```text
给定一个由 0 和 1 组成的矩阵 mat ，
  请输出一个大小相同的矩阵，
  其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。 

两个相邻元素间的距离为 1 。 


示例 1： 


输入：mat = [[0,0,0],
            [0,1,0],
            [0,0,0]]
输出：[[0,0,0],
      [0,1,0],
      [0,0,0]]


示例 2： 

输入：mat = [[0,0,0],
            [0,1,0],
            [1,1,1]]
输出：[[0,0,0],
      [0,1,0],
      [1,2,1]]


提示： 

m == mat.length 
n == mat[i].length 
1 <= m, n <= 10⁴ 
1 <= m * n <= 10⁴ 
mat[i][j] is either 0 or 1. 
mat 中至少有一个 0 
```

# 读题

- 计算每个节点到最近一个0 的距离

# 法一：动态规划

- 核心：动态规划

## 思路

- 定义一个矩阵，记录每个节点到 最近一个0 的距离
- 搜索方向：左上 => 右下
  - 假设左上角存在一个 0节点
  - 寻找每个节点 到 其左上方最近一个0 的距离
    - 跳过 0节点
    - 第1列：设置默认值
    - 其它列：与同一行的前一列 比较
    - 其它行(第1行除外)：与同一列的前一行 比较
- 搜索方向：右下 => 左上
  - 假设右下角存在一个 0节点
  - 计算当前节点到 0节点的 最短距离
    - min(【`当前节点` 到 `左上方最近一个0节点` 的距离】, 【`当前节点` 到 `右下方最近一个0节点` 的距离】)
    - 跳过 0节点
    - 其它列(最后1列除外)：与同一行的后一列 比较
    - 其它行(最后1行除外)：与同一列的后一行 比较

## 实现

### 边界问题

- 边界行(或 列)，只需与同一列(或 行)的相邻节点比较
  - `左上 => 右下`：min(`当前节点`, `前一个节点`)
    - 注意：左上角顶点没有 `前一个节点`
  - `右下 => 左上`：min(`当前节点`, `后一个节点`)
    - 注意：右下角顶点没有 `后一个节点`

### 细节问题

- 节点距离默认值，可以在 `左上 => 右下` 搜索时赋值
  - 节省一次 `O(mn)` 遍历

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(mn)` | `O(mn)` + `O(1)` </br> - `O(mn)` : 结果集 </br> - `O(1)` : 行数/列数/默认值
时间 | `O(mn)` | `O(mn)` </br> - `左上 => 右下` 搜索 </br> - `右下 => 左上` 搜索

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | 只有一个节点
其次 | `O(mn)` | `O(mn)` | 只有一个 1节点
最坏 | `O(mn)` | `O(mn)` | 多个 1节点
