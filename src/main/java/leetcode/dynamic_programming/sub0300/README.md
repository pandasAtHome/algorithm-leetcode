# 题目

- Java：[300]最长递增子序列
- Related Topics 数组 二分查找 动态规划 👍 2843 👎 0

```text
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 

子序列 是由数组派生而来的序列，
  删除（或不删除）数组中的元素而不改变其余元素的顺序。
  例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 


示例 1： 

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。


示例 2： 

输入：nums = [0,1,0,3,2,3]
输出：4


示例 3： 

输入：nums = [7,7,7,7,7,7,7]
输出：1


提示： 

1 <= nums.length <= 2500 
-10⁴ <= nums[i] <= 10⁴ 


进阶： 

你能将算法的时间复杂度降低到 O(n log(n)) 吗? 
```

# 读题

- 找出一个数组中的最长递增子序列
  - 子序列的元素在 数组 中，可以是不连续的

# 法一：动态规划 + 二分查找

- 核心：
  - 动态规划：记录最长子序列
  - 二分查找：确保子序列的每个元素是最小的

## 思路

- 定义一个数组，记录当前的最长子序列
- 遍历数组的每个元素，找出最长子序列
  - 比子序列的最大元素 大，直接插入到队尾， len +1
  - 比子序列的最大元素 小，替换子序列中，刚好比 nums[i] 小的元素

## 实现

### 边界问题

- 默认 数组的第一个元素为 最长子序列
- 数组只有一个元素

### 细节问题

- 记录 最接近 target 的位置（即：`target > dp[mid]  =>  pos = mid`）

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 记录最长子序列
时间 | `O(n log n)` | `O(n log n)` </br> - 遍历数组 & 更新最长子序列

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 细节问题2
其次 | `O(n)` | `O(n)` | - 数组为递增序列
最坏 | `O(n)` | `O(n log n)` | - 其他
