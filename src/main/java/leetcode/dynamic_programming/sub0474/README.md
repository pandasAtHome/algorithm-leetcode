# 题目

- Java：[474]一和零
- Related Topics 数组 字符串 动态规划 👍 813 👎 0

```text
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 
  请你找出并返回 strs 的最大子集的长度，
  该子集中 最多 有 m 个 0 和 n 个 1 。 

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 


示例 1： 

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。
  {"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。


示例 2： 

输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。


提示： 

1 <= strs.length <= 600 
1 <= strs[i].length <= 100 
strs[i] 仅由 '0' 和 '1' 组成 
1 <= m, n <= 100 
```

# 读题

- 在一个数组中，找出并获取 最大子集的长度
  - 数组：元素是 由 `0-1` 字符组成的字符串
  - 最大子集中： `0 的个数 <= m` & `1 的个数 <= n`

# 法一：动态规划

- 核心：：动态规划（多维 0-1 背包）

## 思路

- 定义一个数组：记录截止到当前的字符串 可组成的最大子集的长度
- 遍历所有字符串，计算 可组成的最大子集的长度
  - 计算当前字符串中包含的 `0` 和 `1` 的个数
  - 找到符合题意的子集，记录最大的子集

## 实现

### 边界问题

- 只有一个元素

### 细节问题

- 逆向遍历，压缩空间，减少遍历范围

### [代码实现](Demo01.java)

### 复杂度

- `l`：数组长度
- `m`：0 的个数
- `n`：1 的个数
- `s`：数组中的元素的长度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(mn)` | `O(mn)` </br> - 记录 可组成的最大子集的长度
时间 | `O(lmn)` | `O(lmn)` + `O(s)` </br> - `O(lmn)` : 遍历数组 & `0与1` 的个数
 </br> - `O(s)` : 字符串长度

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(mn)` | `O(lmn)` | - 其他
