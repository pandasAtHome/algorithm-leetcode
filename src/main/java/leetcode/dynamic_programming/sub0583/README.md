# 题目

- Java：[583]两个字符串的删除操作
- Related Topics 字符串 动态规划 👍 507 👎 0

```text
给定两个单词 word1 和 word2 ，
  返回使得 word1 和 word2 相同所需的最小步数。 
  每步 可以删除任意一个字符串中的一个字符。 


示例 1： 

输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 
  第一步将 "sea" 变为 "ea" ，
  第二步将 "eat" 变为 "ea"


示例 2: 

输入：word1 = "leetcode", word2 = "etco"
输出：4


提示： 

1 <= word1.length, word2.length <= 500 
word1 和 word2 只包含小写英文字母 
```

# 读题

- 只能通过删除操作，找出两个单词的最大公共子串

# 法一：动态规划

- 核心：动态规划

## 思路

- 定义一个数组： `dp[i][j]` 表示 `word1[0:i)` 变为 `word2[0:j)` 最少需要多少步
- 匹配 `word1` 和 `word2` 的最大公共子串

## 实现

### 边界问题

- `word1` 为空
- `word2` 为空

### 细节问题

- `word2` 变为 字符数组，加快检索

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(mn)` | `O(mn)` </br> - 记录 `word1[0:i)` 变为 `word2[0:j)` 所需的最少步数
时间 | `O(mn)` | `O(mn)` + `O(m)` + `O(n)` </br> - `O(mn)` : 遍历 `word1` 和 `word2` </br> - `O(m)` : 遍历 `word2` </br> - `O(n)` : 遍历 `word1`

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1 & 边界问题2
最坏 | `O(mn)` | `O(mn)` | - 其他
