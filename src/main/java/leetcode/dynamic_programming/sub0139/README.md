# 题目

- Java：[139]单词拆分
- Related Topics 字典树 记忆化搜索 哈希表 字符串 动态规划 👍 1840 👎 0

```text
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。
  请你判断是否可以利用字典中出现的单词拼接出 s 。 

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 


示例 1： 

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。


示例 2： 

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。


示例 3： 

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false


提示： 

1 <= s.length <= 300 
1 <= wordDict.length <= 1000 
1 <= wordDict[i].length <= 20 
s 和 wordDict[i] 仅有小写英文字母组成 
wordDict 中的所有字符串 互不相同 
```

# 读题

- 字典词库中的字符串是否能组成一个单词
- 字符串可重复使用

# 法一：动态规划

- 核心：动态规划

## 思路

- 定义一个列表：记录 目标字符串 s 中，以 `每个位置的字母` 为结尾 是否能匹配上
- 把词典 转为 hash 表
- 遍历 截止到 目标字符串s 的每个位置字母，找出 所有子串
  - 目标字符串 s 的 `[0, j)` 子串 已经匹配上，且 `[j, i)` 在 hash 词典中

## 实现

### 边界问题

- 第一个为空格，一定能匹配上

### 细节问题

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 记录 截止至每个位子的字母是否能匹配上
时间 | `O(n^2)` | `O(n^2)` </br> - 遍历每个字母，及截止到当前字母的每个子串

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 字符串s 的长度为1
最坏 | `O(n)` | `O(n^2)` | - 多个字符
