# 题目

- Java：[1143]最长公共子序列
- Related Topics 字符串 动态规划 👍 1150 👎 0

```text
给定两个字符串 text1 和 text2，
  返回这两个字符串的最长 公共子序列 的长度。
  如果不存在 公共子序列 ，返回 0 。 

一个字符串的 子序列 是指这样一个新的字符串：
  它是由原字符串在不改变字符的相对顺序的情况下删除某些字符
  （也可以不删除任何字符）后组成的新字符串。 

例如，"ace" 是 "abcde" 的子序列，
  但 "aec" 不是 "abcde" 的子序列。 

两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 


示例 1： 

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。


示例 2： 

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。


示例 3： 

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。


提示： 

1 <= text1.length, text2.length <= 1000 
text1 和 text2 仅由小写英文字符组成。 
```

# 读题

- 找出两个字符串的 最长公共子串的长度
  - 最长公共子串，只需在原字符串中保持位置的相对顺序

# 法一：动态规划

- 核心：动态规划

## 思路

- 定义一个二维数组，
  - `dp[i][j]` 表示 `text1 的 [0, i) 子串` 与 `text2 的 [0, j) 子串` 的最长公共子串的长度
- 匹配两个字符串的每个字符，找出最长公共子串的长度
  - 找到相同字符：在 `[0, i - 1)` 和 `[0, j - 1)` 的最长公共子串的长度 + 1
  - 没找到相同字符：保持当前的最长公共子串的长度

## 实现

### 边界问题

### 细节问题

- 把 待匹配的字符串 转为数组，提高字符查找效率

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(mn)` | `O(mn)` + `O(n)` </br> - `O(mn)` : 记录最长公共子串的长度 </br> - `O(n)` : 带匹配字符串的字节数组
时间 | `O(mn)` | `O(mn)` </br> - 遍历两个字符串字符

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 两个字符串长度都为1
最好 | `O(mn)` | `O(mn)` | - 其他
