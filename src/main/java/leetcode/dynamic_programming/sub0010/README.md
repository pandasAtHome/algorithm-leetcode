# 题目

- Java：[10]正则表达式匹配
- Related Topics 递归 字符串 动态规划 👍 3282 👎 0

```text
给你一个字符串 s 和一个字符规律 p，
  请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 
    '.' 匹配任意单个字符 
    '*' 匹配零个或多个前面的那一个元素 

所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 


示例 1： 

输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。


示例 2: 

输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。


示例 3： 

输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。


提示： 

1 <= s.length <= 20 
1 <= p.length <= 30 
s 只包含从 a-z 的小写字母。 
p 只包含从 a-z 的小写字母，以及字符 . 和 *。 
保证每次出现字符 * 时，前面都匹配到有效的字符 
```

# 读题

- 实现一个支持 `.` 和 `*` 的正则表达式匹配
  - `.`: 匹配任意单个字符
  - `*`: 匹配零个或多个前面的那一个元素

# 法一：动态规划

- 核心：动态规划

## 思路

- 定义一个数组：`dp[i][j]` 表示 `s[0:i]` 与 `p[0:j]` 是否匹配上
- 由于每次出现 `*` 之前，都能匹配到有效字符，所以不用添加 `j > 1` 的判断

## 实现

### 边界问题

- `dp[0][0]` 表示 空字符串，一定能匹配上
- 只有一个字符：`s.length() == 1`

### 细节问题

- 把 `匹配规则 p` 转为 字符数组 （加快 对 p 的字符检索）

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(mn)` | `O(mn)` + `O(m)` </br> - `O(mn)`: 记录 `s[0:i]` 与 `p[0:j]` 是否匹配 </br> - `O(m)`: 找出 `p` 中的所有 `*`
时间 | `O(mn)` | `O(mn)` + `O(m)` </br> - `O(mn)`: 遍历并匹配字符 </br> - `O(m)`: 找出 `p` 中的所有 `*`

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题2
最坏 | `O(mn)` | `O(mn1)` | - 多个字符
