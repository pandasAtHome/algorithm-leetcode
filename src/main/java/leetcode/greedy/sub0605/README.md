# 题目

- Java：[605]种花问题
- Related Topics 贪心 数组 👍 477 👎 0

```text
假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。
可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 

给你一个整数数组 flowerbed 表示花坛，
  由若干 0 和 1 组成，
  其中 0 表示没种植花，
  1 表示种植了花。
另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？
能则返回 true ，不能则返回 false。 


示例 1： 

输入：flowerbed = [1,0,0,0,1], n = 1
输出：true


示例 2： 

输入：flowerbed = [1,0,0,0,1], n = 2
输出：false


提示： 

1 <= flowerbed.length <= 2 * 10⁴ 
flowerbed[i] 为 0 或 1 
flowerbed 中不存在相邻的两朵花 
0 <= n <= flowerbed.length 
```

# 读题

- 花不能种植在相邻的地块上
- 能否在不打破种植规则的情况下种入 n 朵花

# 法一：贪心算法

## 思路

- 寻找已经种了花的位置：`flowerbed[i] == 1`

```java
if (flowerbed[i] == 1) {
    ...
}
```

- 计算可种植数量
  - 没种过花 => left可种植，right不可种植
  - 有种过花 => left & right 均不可种植

```java
if (prev < 0) {
    // 3.1、之前都没种过花
    //   => left可种植，right不可种植
    // 可种植数量：
    //   => numOfPlant = (i - prev - 1) / 2,  prev = -1
    //   => numOfPlant = i / 2
    // 举例：
    //   [0, 0, 1, ...]  =>  可种植 1朵
    //   [0, 1, 1, ...]  =>  不可种植
    n -= (i / 2);
} else {
    // 3.2、之前有种过花
    //   => left & right 均不可种植
    // 可种植数量：
    //   => numOfPlant = (i - prev - 2) / 2
    // 举例：
    //   [1, 0, 0, 0, 1, ...]  =>  可种植 1朵
    //   [1, 0, 0, 1, 1, ...]  =>  不可种植
    n -= ((i - prev - 2) / 2);
}
```

- 记录当前种了花的位置

```java
prev = i;
```

- 仍然有需要种植的花，计算剩余可种植数量
  - 所有位置均可种植
  - 剩余可种植位置数量

```java
if (prev < 0) {
    // 6.1、所有位置均可种植
    // 举例：
    //   [0]  =>  可种植 1朵
    n -= (flowerbedLen + 1) / 2;
} else {
    // 6.2、剩余可种植位置数量
    // 举例：
    //   [0, 1, 0, 0, 0]  =>  可种植 1朵
    n -= (flowerbedLen - prev - 1) / 2;
}
```

## 实现

### 边界问题

- 边界问题：无需种植

```java
if (n == 0) {
    return true;
}
```

- 边界问题：已经没有了需要种植的花

```java
if (n <= 0) {
    return true;
}
```

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `3 * O(1)` </br> - `O(1)` : 3个数值变量
时间 | `O(n)` | `O(3n)` + `O(n)` </br> - `O(3n)` : 数组遍历 </br> - `O(n)` : 是否种花判断
