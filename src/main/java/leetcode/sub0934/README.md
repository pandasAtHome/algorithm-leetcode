# 题目

- Java：[934]最短的桥
- Related Topics 深度优先搜索 广度优先搜索 数组 矩阵 👍 275 👎 0

```text
给你一个大小为 n x n 的二元矩阵 grid ，
  其中 1 表示陆地，0 表示水域。 

岛 是由四面相连的 1 形成的一个最大组，
  即不会与非组内的任何其他 1 相连。
  grid 中 恰好存在两座岛 。 

你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。 

返回必须翻转的 0 的最小数目。 


示例 1： 

输入：grid = [[0,1],
             [1,0]]
输出：1


示例 2： 

输入：grid = [[0,1,0],
             [0,0,0],
             [0,0,1]]
输出：2


示例 3： 

输入：grid = [[1,1,1,1,1],
             [1,0,0,0,1],
             [1,0,1,0,1],
             [1,0,0,0,1],
             [1,1,1,1,1]]
输出：1


提示： 

n == grid.length == grid[i].length 
2 <= n <= 100 
grid[i][j] 为 0 或 1 
grid 中恰有两个岛 
```

# 读题

- 找出连通两个岛屿的最短路径

# 法一：广度优先搜索

- 核心：DFS + BFS

## 思路

- 找到第一个陆地节点(`grid[row][col] = 1`)
- 通过 DFS：
  - 标记出岛屿的所有陆地节点
  - 岛屿的海岸线（与岛屿相邻的海洋节点）
    - 用于搜索抵达第二岛屿的路径
- 通过 BFS 找出抵达另一个岛屿的最短路径长度
  - 遍历当前一轮的所有海洋节点，搜索第二个岛屿，遇到：
    - 海洋节点：记录，用于下一轮搜索
    - 陆地节点：返回当前搜索次数
    - 已标记节点：跳过

## 实现

### 边界问题

- 只搜索矩阵内的节点
- 第一岛屿搜索：首次遇到陆地节点，开始搜索岛屿的所有节点
- 第二岛屿搜索：遇到陆地节点，结束搜索

### 细节问题

- 由于使用 DFS 搜索的前提是：`grid[row][col] == 1`，所以 `剪枝` 可以放在方向搜索上执行

### [代码实现](/src/main/java/leetcode/sub0934/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n^2)` | `O(n^2)` </br> - 递归栈空间
时间 | `O(n^2)` | `O(n^2)` </br> - DFS递归 + BFS

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好/坏 | `O(n^2)` | `O(n^2)` | 所有情况
