# 题目

- Java：[40]组合总和 II
- Related Topics 数组 回溯 👍 1130 👎 0

```text
给定一个候选人编号的集合 candidates 和一个目标数 target ，
  找出 candidates 中所有可以使数字和为 target 的组合。 
  candidates 中的每个数字在每个组合中只能使用 一次 。 

注意：解集不能包含重复的组合。 


示例 1: 

输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[[1,1,6],
 [1,2,5],
 [1,7],
 [2,6]] 


示例 2: 

输入: candidates = [2,5,2,1,2], target = 5,
输出:
[[1,2,2],
 [5]] 


提示: 

1 <= candidates.length <= 100 
1 <= candidates[i] <= 50 
1 <= target <= 30 
```

# 读题

- 在一个集合中找出所有组合之和为target的元素组合
- 每个元素只能用一次
- 组合不可重复

# 法一：深度优先搜索

- 核心：深度优先搜索 + 回溯

## 思路

- 对集合进行升序排序，过滤大于 target 的元素
- 定义一个组合路径
- 回溯寻找组合

## 实现

### 边界问题

- 退出条件：找到 `组合之和 = target`

### 细节问题

- `当前组合之和 > target` => `break`
- 每次搜索元素，只搜索当前元素之后的元素

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(log n)` | `O(log n)` + `O(L)` </br> - `O(log n)` : 排序栈空间 </br> - `O(L)` : 组合元素空间
时间 | `O(n log n)` | `O(n log n)` + $O(C_{n}^{L})$ </br> - `O(n log n)` : 排序 </br> - $O(C_{n}^{L})$ : 回溯搜索元素

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | 只有一个元素
其次 | `O(log n)` | `O(n log n)` | 所有元素都大于 target
最坏 | `O(log n)` | `O(n log n)` | 其他情况
