# 题目

- Java：[130]被围绕的区域
- Related Topics 深度优先搜索 广度优先搜索 并查集 数组 矩阵 👍 874 👎 0

```text
给你一个 m x n 的矩阵 board ，
  由若干字符 'X' 和 'O' ，
  找到所有被 'X' 围绕的区域，
  并将这些区域里所有的 'O' 用 'X' 填充。


示例 1： 

输入：board = [["X","X","X","X"],
              ["X","O","O","X"],
              ["X","X","O","X"],
              ["X","O","X","X"]]
输出：[["X","X","X","X"],
      ["X","X","X","X"],
      ["X","X","X","X"],
      ["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，
  换句话说，任何边界上的 'O' 都不会被填充为 'X'。 
  任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都
会被填充为 'X'。
如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。


示例 2： 

输入：board = [["X"]]
输出：[["X"]]


提示： 

m == board.length 
n == board[i].length 
1 <= m, n <= 200 
board[i][j] 为 'X' 或 'O' 
```

# 读题

- 找出被 'X' 包围的 所有 '0' 的区域，并用 'X' 填充
- 4个方向边界上 及 与之相连的 '0' 都不能被 'X' 填充

# 法一：广度优先搜索

- 核心：广度优先搜索 + 标记

## 思路

- 从边界出发，找出不可替换位
  - 边界上的 `O` 以及与之相连的坐标，标记为 `A`
- 替换检测
  - `A` => `O`
  - `O` => `X`

## 实现

### 边界问题

- 只检测矩阵内的节点

### 细节问题

- 行数 或 列数 少于 2
- 在矩阵中，新增一个标识符 `A` 表示不可替换的 `O` ，在替换检测时重新改回 `O`

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(2n + 2m)` | `O(2n + 2m)` </br> - 不可替换节点检测
时间 | `O(mn)` | `O(2n + 2m)` + `O(nm)` </br> - `O(2n + 2m)` : 不可替换节点检测 </br> - `O(nm)` : 替换检测

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | 细节问题1
最坏 | `O(2n + 2m)` | `O(nm)` | 其他
