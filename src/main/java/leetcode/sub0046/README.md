# 题目

- Java：[46]全排列
- Related Topics 数组 回溯 👍 2222 👎 0

```text
给定一个不含重复数字的数组 nums ，
  返回其 所有可能的全排列 。
你可以 按任意顺序 返回答案。 


示例 1： 

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]


示例 2： 

输入：nums = [0,1]
输出：[[0,1],[1,0]]


示例 3： 

输入：nums = [1]
输出：[[1]]


提示： 

1 <= nums.length <= 6 
-10 <= nums[i] <= 10 
nums 中的所有整数 互不相同 
```

# 读题

- 获取一个数组所有的可能的排序方式

# 法一：回溯法

- 核心：深度优先搜索 + 回溯

## 思路

- 创建一个列表，记录每个数字是否被使用
- 创建一个队列，用于存放当前的排序方式
- 寻找可能的排序方式
  - 遍历数字，锁定当前要使用的数字（后续遍历不可重复用）
  - 把当前数字加入队列
  - 继续寻找下一个可用的数字
  - 把当前数字移出队列，寻找下一种可能的排序方式
  - 解锁，对下一种可能的排序方式开放 当前数字的使用权限

## 实现

### 边界问题

- 退出条件：`当前队列的长度 == 数组长度`

### 细节问题

- 选用 `n - 1 == level` 最为递归的结束条件
  - `n == level` 已可以作为结束条件，但是会多一次递归

### [代码实现](/src/main/java/leetcode/sub0046/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 数字使用记录队列 </br> - 当前排序方式 </br> - 寻找排序方式消耗的栈空间
时间 | `O(n^2)` | `O(O(n^2)` </br> - 寻找可能的排序方式

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(n)` | `O(1)` | 只有一个元素
最坏 | `O(n)` | `O(n^2)` | 多个元素
