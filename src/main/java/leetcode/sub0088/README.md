# 题目

- Java：[88]合并两个有序数组
- Related Topics 数组 双指针 排序 👍 1540 👎 0

```text
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，
  另有两个整数 m 和 n ，
  分别表示 nums1 和 nums2 中的元素数目。 

请你 合并 nums2 到 nums1 中，
  使合并后的数组同样按 非递减顺序 排列。 

注意：
  最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。
  为了应对这种情况，
    nums1 的初始长度为 m + n，
      其中前 m 个元素表示应合并的元素，
      后 n 个元素为 0 ，应忽略。
    nums2 的长度为 n 。 


示例 1： 

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。


示例 2： 

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。


示例 3： 

输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，
  因为 m = 0 ，所以 nums1 中没有元素。
  nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。


提示： 

nums1.length == m + n 
nums2.length == n 
0 <= m, n <= 200 
1 <= m + n <= 200 
-10⁹ <= nums1[i], nums2[j] <= 10⁹ 


进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？ 
```

# 读题

- 两个按 非递减顺序 排列的整数数组
- 使合并后的数组同样按 非递减顺序 排列
- `nums1.length == m + n`
- `nums2.length == n`

# 法一：双指针

- 核心：双指针同向移动

## 思路

- 从右往左遍历，最大值先入队
  - 左边大，左边入队，移动左指针
  - 一样大，都入队，左右指针都移动
  - 右边大，右边入队，移动右指针

## 实现

### 边界问题

- 1、右数组为空(`n == 0`)，无需处理
- 2、左数组为空(`m == 0`)，右数组入队，结束

### 细节问题

- 1、左数组尾元素 等于 右数组头元素(`num1[m-1] == num2[0]`)，右数组入队，结束
- 2、右数组还有元素未入队时，`pos == n`
  - 此时，n 为右数组中，未入队的最后一个元素的索引

### [代码实现](/src/main/java/leetcode/sub0088/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `3 * O(1)` </br> - `O(1)` : 3个数值变量
时间 | `O(m + n)` | `O(m+n)` + `O(2n)` + `O(4n)` + `O(3n)` </br> - `O(m+n)` : 同时遍历两个数组 </br> - `O(2n)` : 两数组查找元素 </br> - `O(4n)` : 条件判断 & 赋值 & 2次指针挪动 </br> - `O(3n)` : 循环条件判断 & 赋值 & 指针挪动

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | 无 | `O(1)` | 边界问题1
其次 | `O(1)` | `O(n)` | 边界问题2 or 细节问题1
最差 | `O(1)` | `O(m + n)` | 正常情况比较
