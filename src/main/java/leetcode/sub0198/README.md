# 题目

- Java：[198]打家劫舍
- Related Topics 数组 动态规划 👍 2316 👎 0

```text
你是一个专业的小偷，计划偷窃沿街的房屋。
  每间房内都藏有一定的现金，
  影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
  如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 

给定一个代表每个房屋存放金额的非负整数数组，
  计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 


示例 1： 

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后
     偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。 


示例 2： 

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 
     偷窃 3 号房屋 (金额 = 9)，接着
     偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


提示： 

1 <= nums.length <= 100 
0 <= nums[i] <= 400 
```

# 读题

- 计算一晚之内可偷窃的最大金额
- 不能偷窃相邻的两个房间

# 法一：动态规划 - 空间压缩

- 核心：动态规划

## 思路

- 定义一个列表，记录偷窃第 i 个房间时，可获取的最大金额
- 获取最后的最大获利，只需知道最后一个房间是否被偷窃：
  - 偷窃：`当前最大获利 = prev2`
  - 不偷窃：`当前最大获利 = prev1`
- `最终获利` = 最后一个房间 `max(prev1, prev2)`

## 实现

### 边界问题

- 退出条件：`i <= n`
  - 有 n 个房间 `nums` 和 n + 1 个记录

### 细节问题

- 初始化：
- 存量金额的房间编号：`nums` 从 0 开始

### [代码实现](/src/main/java/leetcode/sub0198/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `O(n)` </br> - 记录偷窃到当前房间 `偷窃 or 不偷窃` 的最大获利
时间 | `O(n)` | `O(n)` </br> - 遍历每个房间

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | 只有一个房间
最坏 | `O(1)` | `O(n)` | 多个房间

# 法二：动态规划 - 一维数组

- 核心：动态规划

## 思路

- 定义一个列表，记录偷窃第 i 个房间时，可获取的最大金额
- 遍历每个房间，计算截止到当前房间，`可获取的最大金额 = max(偷窃, 不偷窃)`
  - 偷窃：
    - `当前可获取的最大金额 dp[i] = 当前房间金额 nums[i - 1] + 往前二间房子可获取的最大金额 dp[i - 2]`
  - 不偷窃：
    - `当前可获取的最大金额 dp[i] = 往前一间房子可获取的最大金额 dp[i - 1]`
- `最终获利 = max(dp[n - 1], dp[n])`

## 实现

### 边界问题

- 退出条件：`i <= n`
  - 有 n 个房间 `nums` 和 n + 1 个记录 `dp`

### 细节问题

- 可获取最大金额的房间编号：`dp` 从 1 开始
- 存量金额的房间编号：`nums` 从 0 开始

### [代码实现](/src/main/java/leetcode/sub0198/Demo02.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 记录每个房间可获利的最大值
时间 | `O(n)` | `O(n)` </br> - 遍历每个房间

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | 只有一个房间
最坏 | `O(n)` | `O(n)` | 多个房间
