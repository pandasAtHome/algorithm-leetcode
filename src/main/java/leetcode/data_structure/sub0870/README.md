# 题目

- Java：[870]优势洗牌
- Related Topics 贪心 数组 双指针 排序 👍 363 👎 0

```text
给定两个大小相等的数组 nums1 和 nums2，
  nums1 相对于 nums2 的优势可以用满足 
    nums1[i] > nums2[i] 的索引 i 的数目来描述。 
返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。 


示例 1： 

输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]
输出：[2,11,7,15]


示例 2： 

输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]
输出：[24,32,8,12]


提示： 

1 <= nums1.length <= 10⁵ 
nums2.length == nums1.length 
0 <= nums1[i], nums2[i] <= 10⁹ 
```

# 读题

- 给出两个数组 `nums1` 和 `nums2`，使得尽量多的 `nums1[i] > nums2[i]`

# 法一：排序

- 核心：排序 + 双指针

## 思路

- 定义一个队列，记录 nums2 的每个数字 `nums2[i]` 及其 对应的位置 `i`
- 分别对 `nums1`和  `nums2` 进行升序排序
- 使用田忌赛马的思想进行比较：
  - `nums1[i] > nums2[i]`：放左边
  - `nums1[i] <= nums2[i]`：放右边

## 实现

### 边界问题

### 细节问题

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(log n)` + `O(n)` </br> - `O(log n)`: 排序 </br> - `O(n)`: 记录 nums2
时间 | `O(n)` | `O(n log n)` + `O(n)` </br> - `O(n log n)`: 排序 </br> - `O(n)`: 遍历 nums1

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 只有1 个元素
最坏 | `O(n)` | `O(n log n)` | - 其他
