# 题目

- Java：[240]搜索二维矩阵 II
- Related Topics 数组 二分查找 分治 矩阵 👍 1185 👎 0
  
```text
编写一个高效的算法
  来搜索 m x n 矩阵 matrix 中的一个目标值 target 。
  该矩阵具有以下特性： 
    每行的元素从左到右升序排列。 
    每列的元素从上到下升序排列。 


示例 1： 

输入：matrix = [[1,4,7,11,15],
               [2,5,8,12,19],
               [3,6,9,16,22],
               [10,13,14,17,24],
               [18,21,23,26,30]], 
     target = 5
输出：true


示例 2： 

输入：matrix = [[1,4,7,11,15],
               [2,5,8,12,19],
               [3,6,9,16,22],
               [10,13,14,17,24],
               [18,21,23,26,30]], 
     target = 20
输出：false


提示： 

m == matrix.length 
n == matrix[i].length 
1 <= n, m <= 300 
-10⁹ <= matrix[i][j] <= 10⁹ 
每行的所有元素从左到右升序排列 
每列的所有元素从上到下升序排列 
-10⁹ <= target <= 10⁹ 
```

# 读题

- 在一个有序（从左到右升序，从上到下升序）的矩阵中，查找目标值是否存在

# 法一：Z字查询

- 核心：Z字查询

## 思路

- 从矩阵的右上角往左下角搜索
  - 比目标值大，左移
  - 比目标值小，下移

## 实现

### 边界问题

- `1 * 1` 矩阵

### 细节问题

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `O(1)` </br> - 矩阵的长宽
时间 | `O(m + n)` | `O(m + n)` </br> - Z字查找

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(1)` | `O(m + n)` | - `target` 存在矩阵中
最坏 | `O(1)` | `O(m + n)` | - 其他
