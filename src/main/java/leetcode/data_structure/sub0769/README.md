# 题目

- Java：[769]最多能完成排序的块
- Related Topics 栈 贪心 数组 排序 单调栈 👍 373 👎 0

```text
给定一个长度为 n 的整数数组 arr ，
  它表示在 [0, n - 1] 范围内的整数的排列。 
我们将 arr 分割成若干 块 (即分区)，
  并对每个块单独排序。
将它们连接起来后，
  使得连接的结果和按升序排序后的原数组相同。 
返回数组能分成的最多块数量。 


示例 1: 

输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，
  这不是有序的数组。


示例 2: 

输入: arr = [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
对每个块单独排序后，结果为 [0, 1], [2], [3], [4]


提示: 

n == arr.length 
1 <= n <= 10 
0 <= arr[i] < n 
arr 中每个元素都 不同 
```

# 读题

- 求一个 `[0, n-1]` 的数组，可以分成多少块，排序后连在一块的结果
- 与原数组排序后的结果一致

# 法一：单调栈

- 核心：单调栈

## 思路

- 创建一个单调栈
- 把递增排序的数字都入栈
- 把递减的数字出栈
- 保留 递减序列中的最大值

## 实现

### 边界问题

- 只有一个元素

### 细节问题

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 记录递增序列
时间 | `O(n)` | `O(n)` </br> - 遍历所有数字

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(n)` | `O(n)` | - 其他
