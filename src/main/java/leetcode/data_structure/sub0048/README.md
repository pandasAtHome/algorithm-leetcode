# 题目

- Java：[48]旋转图像
- Related Topics 数组 数学 矩阵 👍 1504 👎 0

```text
给定一个 n × n 的二维矩阵 matrix 表示一个图像。
  请你将图像顺时针旋转 90 度。 

你必须在 原地 旋转图像，
  这意味着你需要直接修改输入的二维矩阵。
  请不要 使用另一个矩阵来旋转图像。 


示例 1： 

输入：matrix = [[1,2,3],
               [4,5,6],
               [7,8,9]]
输出：
[[7,4,1],
 [8,5,2],
 [9,6,3]]


示例 2： 

输入：matrix = [[5, 1, 9, 11],
               [2, 4, 8, 10],
               [13,3, 6, 7 ],
               [15,14,12,16]]
输出：
[[15,13,2, 5 ],
 [14,3, 4, 1 ],
 [12,6, 8, 9 ],
 [16,7, 10,11]]


提示： 

n == matrix.length == matrix[i].length 
1 <= n <= 20 
-1000 <= matrix[i][j] <= 1000 
```

# 读题

- 把一个 `n x n` 的矩阵按顺时针原地旋转90度（过程如下：）

```text
原型
[[5, 1, 9, 11],
 [2, 4, 8, 10],
 [13,3, 6, 7 ],
 [15,14,12,16]]

i = 0; j = 0
[[15,1, 9, 5],
 [2, 4, 8, 10],
 [13,3, 6, 7 ],
 [16,14,12,11]]

i = 0; j = 1
[[15,13,9, 5],
 [2, 4, 8, 1],
 [12,3, 6, 7 ],
 [16,14,10,11]]

i = 0; j = 2
[[15,13,2, 5],
 [14,4, 8, 1],
 [12,3, 6, 9 ],
 [16,7, 10,11]]

i = 1; j = 1
[[15,13,2, 5],
 [14,3, 4, 1],
 [12,6, 8, 9 ],
 [16,7, 10,11]]
```

# 法一：原地交换

- 核心：原地交换（回型收缩交换）

## 思路

- 从外层向内层，按 `回字形` 对值进行原地交换

## 实现

### 边界问题

- `n = 1`，无需旋转

### 细节问题

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `O(1)` </br> - 原地旋转
时间 | `O(n^2)` | `O(n^2)` </br> - 遍历矩阵各个元素

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(1)` | `O(n^n)` | - 其他

# 法二：原地交换

- 核心：原地交换（矩阵位置交换）

## 思路

- 以矩阵的中心为轴，把 `n x n` 矩阵拆分为 4个 `(n / 2) x ((n + 1) / 2)`
- 交换各个小矩阵的位置

## 实现

### 边界问题

- `n = 1`，无需旋转

### 细节问题

### [代码实现](Demo02.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `O(1)` </br> - 原地旋转
时间 | `O(n^2)` | `O(n^2)` </br> - 遍历矩阵各个元素

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(1)` | `O(n^n)` | - 其他
