# 题目

- Java：[332]重新安排行程
- Related Topics 深度优先搜索 图 欧拉回路 👍 717 👎 0

```text
给你一份航线列表 tickets ，
  其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。
  请你对该行程进行重新规划排序。 
所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，
  所以该行程必须从 JFK 开始。
  如果存在多种有效的行程，
  请你按字典排序返回最小的行程组合。 
例如，
  行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，
  排序更靠前。 
假定所有机票至少存在一种合理的行程。
  且所有的机票 必须都用一次 且 只能用一次。 


示例 1： 

输入：tickets = [["MUC","LHR"],
                ["JFK","MUC"],
                ["SFO","SJC"],
                ["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]


示例 2： 

输入：tickets = [["JFK","SFO"],
                ["JFK","ATL"],
                ["SFO","ATL"],
                ["ATL","JFK"],
                ["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 
  ["JFK","SFO","ATL","JFK","ATL","SFO"] ，
  但是它字典排序更大更靠后。


提示： 

1 <= tickets.length <= 300 
tickets[i].length == 2 
fromi.length == 3 
toi.length == 3 
fromi 和 toi 由大写英文字母组成 
fromi != toi 
```

# 读题

- 给出某人行程的一组机票信息：`[起点, 终点]`
- 从 JFK 出发，请规划一条行程规划
  - 每张机票必须且仅能用一次
  - 行程终点名字小的排前面

# 法一：深度优先搜索

- 核心：深度优先搜索 + 优先队列

## 思路

- 建立站点路径：{起始站: 终点站列表}
  - 按终点站名字升序
- 从 JFK 出发，寻找所有路径

## 实现

### 边界问题

- 只有一张机票

### 细节问题

- 入队条件：
  - 已经是终点站：queue == null
  - 起始站的机票已经遍历完

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 记录：起点-终点列表
时间 | `O(n)` | `O(n)` </br> - 遍历机票

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(n)` | `O(n)` | - 其他
