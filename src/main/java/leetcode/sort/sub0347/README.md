# 题目

- Java：[347]前 K 个高频元素
- Related Topics 数组 哈希表 分治 桶排序 计数 快速选择 排序 堆（优先队列） 👍 1316 👎 0

```text
给你一个整数数组 nums 和一个整数 k ，
  请你返回其中出现频率前 k 高的元素。
  你可以按 任意顺序 返回答案。 


示例 1: 

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]


示例 2: 

输入: nums = [1], k = 1
输出: [1] 


提示： 

1 <= nums.length <= 10⁵ 
k 的取值范围是 [1, 数组中不相同的元素的个数] 
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 


进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 
```

# 读题

- 获取序列中，出现频率最高的前 k 个元素

# 法一：快排

- 核心：hash 表 + 快速排序 + 二分法

## 思路

- 统计每个次出现的次数
- 按照词频倒序
- 返回出现频率最高的前k个元素

## 实现

### 边界问题

- 快排退出条件：`left >= right`

### 细节问题

- `不同元素个数 = k`，直接返回
- 只需把出现频率高的元素放前面即可，不一定需要排好序

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `2 * O(n)` + `O(log n)` </br> - `O(n)` : 词频统计（hash表 & 数组） </br> - `O(log n)` : 快排使用的栈空间
时间 | `O(n)` | `2 * O(2n)`</br> - `O(2n)` : 词频统计 & 快速查找

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(n)` | `O(n)` | `nums.length == k`
其次 | `O(n)` | `O(n)` | 细节问题1
最差 | `O(n)` | `O(n)` | 正常情况
