# 题目

- Java：[540]有序数组中的单一元素
- Related Topics 数组 二分查找 👍 543 👎 0

```text
给你一个仅由整数组成的有序数组，
  其中每个元素都会出现两次，
  唯有一个数只会出现一次。 

请你找出并返回只出现一次的那个数。 

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。 


示例 1: 

输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2


示例 2: 

输入: nums =  [3,3,7,7,10,11,11]
输出: 10


提示: 

1 <= nums.length <= 10⁵ 
0 <= nums[i] <= 10⁵ 
```

# 读题

- 在一个有序数组中独立数(只出现一次的元素)

# 法一：二分查找

- 核心：左闭右闭 + 二分查找

## 思路

- 找出第一个 `nums[mid] != nums[mid + 1]`，皆可找到独立数
- 计算出偶数下标：每次只比较 `偶数下标` 和 `奇数下标`
- 独立数出现之前：`nums[偶数] == nums[奇数]`
  - 独立数在右区间
- 独立数出现之后：`nums[偶数] != nums[奇数]`
  - 独立数在左区间

## 实现

### 边界问题

- 退出条件：`left >= right`

### 细节问题

- nums 只有一个元素，其就是独立数
- nums 的长度为偶数，没有独立数

### [代码实现](/src/main/java/leetcode/sub0540/Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `4 * O(1)` </br> - `O(1)` : 4个数值变量
时间 | `O(log n)` | `11 * O(log n)` </br> - `O(log n)` : 1次循环退出条件判断 + 2次赋值 + 4次计算 + 2次元素查找 + 1次比较 + 1次移动指针

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | 细节问题1 和 细节问题2
其次 | `O(1)` | `O(log n)` | 独立数在右半部分
最差 | `O(1)` | `O(log n)` | 独立数在左半部分
