# 题目

- Java：[476]数字的补数
- Related Topics 位运算 👍 325 👎 0

```text
对整数的二进制表示取反（0 变 1 ，1 变 0）后，
  再转换为十进制表示，可以得到这个整数的补数。 

例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。 

给你一个整数 num ，输出它的补数。 


示例 1： 

输入：num = 5
输出：2
解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。


示例 2： 

输入：num = 1
输出：0
解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。


提示： 

1 <= num < 2³¹ 

注意：本题与 1009 https:leetcode-cn.com/problems/complement-of-base-10-integer/ 相同 
```

# 读题

- 求一个整数取反后的值（二进制表示中，把 0 变 1，把 1 变 0）

# 法一：位运算

- 核心：位运算（位掩码）

## 思路

- 找出 `num` 的二进制中最左边为 1 的位（`最高位i`）
- 求 `num` 的位掩码（由 i 个 1 组成的二进制）
  - `mask = (1 << (i + 1)) - 1`
- 解码取反（按位异或）

## 实现

### 边界问题

- `num` 为 `int` 类型，寻找掩码时，最多只需要遍历 31 次

### 细节问题

- 2 的幂次方，返回 `num - 1`

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `O(1)` </br> - 存储 num 的掩码
时间 | `O(log n)` | `O(log n)` </br> - 寻找 num 的最高位

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 细节问题1
最坏 | `O(1)` | `O(log n)` | - 其他
