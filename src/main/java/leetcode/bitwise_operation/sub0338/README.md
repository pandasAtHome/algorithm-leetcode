# 题目

- Java：[338]比特位计数
- Related Topics 位运算 动态规划 👍 1126 👎 0

```text
给你一个整数 n ，
  对于 0 <= i <= n 中的每个 i ，
  计算其二进制表示中 1 的个数 ，
  返回一个长度为 n + 1 的数组 ans 作为答案。 


示例 1： 

输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10


示例 2： 

输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101


提示： 

0 <= n <= 10⁵ 

进阶： 

很容易就能实现时间复杂度为 O(n log n) 的解决方案，
  你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？ 
你能不使用任何内置函数解决此问题吗？
  （如，C++ 中的 __builtin_popcount ） 
```

# 读题

- 给出一个数字n，获取 `[0, n]` 的二进制中包含1的个数
- 把这些个数组成数组，返回

# 法一：位运算

- 核心：位运算 + hash表

## 思路

- 判断当前数字的二进制最右边一位是否 为1
- 数字右移一位，并获取该新数字对应的 1的个数

## 实现

### 边界问题

- `n <= 1` : 返回 n

### 细节问题

- `n = 0` 的二进制中不存在 1，所以从 `n = 1` 开始遍历

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 存储结果集
时间 | `O(n)` | `O(n)` </br> - 遍历 `[0, n]`

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(n)` | `O(n)` | - 其他
