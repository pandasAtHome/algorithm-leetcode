# 题目

- Java：[318]最大单词长度乘积
- Related Topics 位运算 数组 字符串 👍 383 👎 0

```text
给你一个字符串数组 words ，
  找出并返回 length(words[i]) * length(words[j]) 的最大值，
  并且这两个单词不含有公共字母。
  如果不存在这样的两个单词，返回 0 。 


示例 1： 

输入：words = ["abcw","baz","foo","bar","xtfn","abcdef"]
输出：16 
解释：这两个单词为 "abcw", "xtfn"。 


示例 2： 

输入：words = ["a","ab","abc","d","cd","bcd","abcd"]
输出：4 
解释：这两个单词为 "ab", "cd"。 


示例 3： 

输入：words = ["a","aa","aaa","aaaa"]
输出：0 
解释：不存在这样的两个单词。


提示： 

2 <= words.length <= 1000 
1 <= words[i].length <= 1000 
words[i] 仅包含小写字母 
```

# 读题

- 在一个单词数组中，两个单词的长度相乘，求他们的最大值
  - 这两个单词，没有相同的字母

# 法一：位运算

- 核心：位运算（位掩码）

## 思路

- 计算每个单词的位掩码
  - 掩码含义：
    - 字母：`zyxwvutsrqponmlkjihgfedcba`
    - 掩码：`11111111111111111111111111`
- 与其他单词比较，判断两个单词是否存在相同的字母
  - 不存在：`maskA & maskB == 0`
- 计算单词长度乘积，并求出最大值

## 实现

### 边界问题

### 细节问题

- 每次只需对【当前单词】&【之前的单词】比较

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 记录每个单词的位掩码
时间 | `O(mn + n^2)` | `O(mn + n^2)` </br> - `遍历单词数组 & (每个单词字母 or 单词比较)`

### 总结

- `m` : 单词长度
- `n` : 数组长度

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(n)` | `O(mn + n^2)` | -
