# 题目

- Java：[268]丢失的数字
- Related Topics 位运算 数组 哈希表 数学 二分查找 排序 👍 670 👎 0

```text
给定一个包含 [0, n] 中 n 个数的数组 nums ，
  找出 [0, n] 这个范围内没有出现在数组中的那个数。 


示例 1： 

输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，
  所以所有的数字都在范围 [0,3] 内。
  2 是丢失的数字，因为它没有出现在 nums 中。 


示例 2： 

输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，
  所以所有的数字都在范围 [0,2] 内。
  2 是丢失的数字，因为它没有出现在 nums 中。 


示例 3： 

输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，
  所以所有的数字都在范围 [0,9] 内。
  8 是丢失的数字，因为它没有出现在 nums 中。 


示例 4： 

输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，
  所以所有的数字都在范围 [0,1] 内。
  1 是丢失的数字，因为它没有出现在 nums 中。 


提示： 

n == nums.length 
1 <= n <= 10⁴ 
0 <= nums[i] <= n 
nums 中的所有数字都 独一无二 

进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 
```

# 读题

- 在 `[0,n]` 中，挑选 n 个数字组成一个数组 `nums`，找出其中缺少的一个数字

# 法一：位运算

- 核心：位运算（异或）

## 思路

- 转换思路：`找出 nums 中缺少的数字 x` => `生成一个 [0,n] 的数组，再与 nums 拼接，找出其中落单的数字`
- 采用 `按位异或` 去除 `两个相同的` 数字

## 实现

### 边界问题

- `n = 1`，返回 `~n`

### 细节问题

- 由于 `x ^ 0 = x`，所以 实际上只需拼接 `[1, n]`

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `O(1)` </br> - 保存缺少的数字
时间 | `O(n)` | `O(n)` </br> - 遍历数组

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(1)` | `O(n)` | - 其他

# 法二：Hash表

- 核心：Hash表

## 思路

- 定义一个长度位 n+1 的数组
- 标记出现过的数字，`result[i] = 1`
- 找出 `result` 中，没出现过的数字(`result[i] == 0`)

## 实现

### 边界问题

- `n = 1`，返回 `~n`

### 细节问题

### [代码实现](Demo02.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(n)` | `O(n)` </br> - 记录出现过的数字
时间 | `O(n)` | `O(n)` </br> - 遍历数组

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(n)` | `O(n)` | - 其他

# 法三：排序

- 核心：排序

## 思路

- 对数组进行排序（获得一个递增数组）
- 遍历 `[0, n]`，找出缺少的数字（i != nums[i]）

## 实现

### 边界问题

- `n = 1`，返回 `~n`

### 细节问题

### [代码实现](Demo03.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(log n)` | `O(log n)` </br> - 排序消耗的栈空间
时间 | `O(n log n)` | `O(n log n)` </br> - 排序

### 总结

情况 | 空间复杂度 | 时间复杂度 | 说明
:--- |:--- |:--- |:---
最好 | `O(1)` | `O(1)` | - 边界问题1
最坏 | `O(log n)` | `O(n log n)` | - 其他
