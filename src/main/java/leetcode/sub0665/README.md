# 题目

- Java：[665]非递减数列
- Related Topics 数组 👍 686 👎 0

```text
给你一个长度为 n 的整数数组 nums ，
  请你判断在 最多 改变 1 个元素的情况下，
  该数组能否变成一个非递减数列。 

我们是这样定义一个非递减数列的： 
  对于数组中任意的 i (0 <= i <= n-2)，
  总满足 nums[i] <= nums[i + 1]。 


示例 1: 

输入: nums = [4,2,3]
输出: true
解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。


示例 2: 

输入: nums = [4,2,1]
输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。


提示： 

n == nums.length 
1 <= n <= 10⁴ 
-10⁵ <= nums[i] <= 10⁵ 
```

# 读题

- 最多 改变 1 个元素，变成一个非递减数列
- 非递减数列定义：`nums[i] <= nums[i + 1]`

# 法一：贪心算法

## 思路

- 比较前两位大小，获取剩余的可修改次数
  - 合规：剩余 1 次
  - 不合规：使用 1 次修改机会，剩余 0 次
- 统计不合规次数 : `nums[i] <= nums[i + 1]`
  - 检查是否还有修改次数，并使用 1次 修改机会
  - `prev > next`  =>  `修改 next 的值`
  - `prev <= next`  =>  `修改 当前 的值`

## 实现

### 边界问题

- 只有一个元素
- for循环：`[1, n - 1]`

### [代码实现](Demo01.java)

### 复杂度

类型 | 复杂度 | 说明
:--- |:--- |:---
空间 | `O(1)` | `5 * O(1)` </br> - `O(1)` : 5个数值变量
时间 | `O(n)` | `O(n)` + `3 * O(1)` </br> - `O(3n)` : for循环 </br> - `O(n)` : 是否合规条件判断 </br> - `O(1)` : 修改判断 和 修改值
