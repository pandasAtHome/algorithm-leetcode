说明：此练习是基于《LeetCode 101: A LeetCode Grinding Guide (C++ Version)》的

# 贪心算法

- 定义：保证每次操作**局部最优**，从而使得**结果最优**
- 核心：局部最优 =》 全局最优
- 常见解题思路：
  - `从左到右` **or** `从右到左`
    - `求两两间最优解` => `总体最优解`
  - `从左到右` **and** `从右到左`
    - `从左到右` => `求两两间最优解` => `目前总体最优解`
    - `从右到左` => `求两两间最优解` => `兼顾 从左到右 得到的最优解` => `最终总体最优解`
- [题目](algorithm-training/1.greedy.md)

# 双指针

- 定义：遍历数组时，使用两个指针指向不同的元素，从而协同完成任务
- 延伸：
  - 多个数组，多个指针
  - 同一数组
    - 遍历**方向相同**，指针不相交
      - 简称：<b style="color: red">滑动窗口</b>
      - 作用：**区间搜索**
    - 遍历**方向相反**
      - 作用：**搜索**
      - 场景：有序数组
- 常见类型：
  - **快慢指针**
    - 核心思想：在环中，快指针必定会追上慢指针 且 相遇
    - 场景：环形数组 or 链表
  - **首尾指针**
    - 核心思想：从首尾两侧向中间靠拢
    - 场景：有序数组查找目标值
- [题目](algorithm-training/2.double_pointer.md)

# 二分查找

- 定义：每次查找时，将待查找区间分成两部分，并只取一部分继续查找
- 场景应用：
  - `有序列表`找目标值
- 常见解题思路：
  - 选择区间：`左闭右开` **or** `左开右闭`
    - 熟练<b style="color: red;">一种</b>即可
  - **死循环**判断：区间只剩 `1 ~ 2` 个值时
- 延伸：
  - 与 `双指针` 比较
    - `双指针`：一步一步移动
    - `二分查找`：每次移动半个区间长度
- [题目](algorithm-training/2.double_pointer.md)

# 排序算法

## 比较

| 算法                                             | 平均时间复杂度      | 最优时间复杂度      | 最坏时间复杂度      | 空间复杂度      | 排序方式        | 稳定性 |
|:-----------------------------------------------|:-------------|:-------------|:-------------|:-----------|:------------|:----|
| [快速排序](/src/main/java/sort/QuickSort.java)     | `O(n log n)` | `O(n log n)` | `O(n^2)`     | `O(log n)` | `in-place`  | 不稳定 |
| [归并排序](/src/main/java/sort/MergeSort.java)     | `O(n log n)` | `O(n log n)` | `O(n log n)` | `O(log n)` | `out-place` | 稳定  |
| [插入排序](/src/main/java/sort/InsertionSort.java) | `O(n^2)`     | `O(n)`       | `O(n^2)`     | `O(1)`     | `in-place`  | 稳定  |
| [冒泡排序](/src/main/java/sort/BubbleSort.java)    | `O(n^2)`     | `O(n)`       | `O(n^2)`     | `O(1)`     | `in-place`  | 稳定  |
| [选择排序](/src/main/java/sort/SelectionSort.java) | `O(n^2)`     | `O(n^2)`     | `O(n^2)`     | `O(1)`     | `in-place`  | 不稳定 |

## 说明

- 排序方式：
  - `in-place`：占用常数内存
  - `out-place`：占用额外内存
- 稳定性：排序前后，值相同的元素，位置是否发生变化