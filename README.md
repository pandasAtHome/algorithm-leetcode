说明：此练习是基于《LeetCode 101: A LeetCode Grinding Guide (C++ Version)》的

# 1.贪心算法

- 定义：保证每次操作**局部最优**，从而使得**结果最优**
- 核心：局部最优 =》 全局最优
- 常见解题思路：
  - `从左到右` **or** `从右到左`
    - `求两两间最优解` => `总体最优解`
  - `从左到右` **and** `从右到左`
    - `从左到右` => `求两两间最优解` => `目前总体最优解`
    - `从右到左` => `求两两间最优解` => `兼顾 从左到右 得到的最优解` => `最终总体最优解`
- [题目](algorithm-training/1.greedy.md)

# 2.双指针

- 定义：遍历数组时，使用两个指针指向不同的元素，从而协同完成任务
- 延伸：
  - 多个数组，多个指针
  - 同一数组
    - 遍历**方向相同**，指针不相交
      - 简称：<b style="color: red">滑动窗口</b>
      - 作用：**区间搜索**
    - 遍历**方向相反**
      - 作用：**搜索**
      - 场景：有序数组
- 常见类型：
  - **快慢指针**
    - 核心思想：在环中，快指针必定会追上慢指针 且 相遇
    - 场景：环形数组 or 链表
  - **首尾指针**
    - 核心思想：从首尾两侧向中间靠拢
    - 场景：有序数组查找目标值
- [题目](algorithm-training/2.double_pointer.md)

# 3.二分查找

- 定义：每次查找时，将待查找区间分成两部分，并只取一部分继续查找
- 场景应用：
  - `有序列表`找目标值
- 常见解题思路：
  - 选择区间：`左闭右开` **or** `左开右闭`
    - 熟练<b style="color: red;">一种</b>即可
  - **死循环**判断：区间只剩 `1 ~ 2` 个值时
- 延伸：
  - 与 `双指针` 比较
    - `双指针`：一步一步移动
    - `二分查找`：每次移动半个区间长度
- [题目](algorithm-training/2.double_pointer.md)

# 4.排序算法

## 4.1比较

| 算法                                             | 平均时间复杂度      | 最优时间复杂度      | 最坏时间复杂度      | 空间复杂度      | 排序方式        | 稳定性 |
|:-----------------------------------------------|:-------------|:-------------|:-------------|:-----------|:------------|:----|
| [快速排序](/src/main/java/sort/QuickSort.java)     | `O(n log n)` | `O(n log n)` | `O(n^2)`     | `O(log n)` | `in-place`  | 不稳定 |
| [归并排序](/src/main/java/sort/MergeSort.java)     | `O(n log n)` | `O(n log n)` | `O(n log n)` | `O(log n)` | `out-place` | 稳定  |
| [插入排序](/src/main/java/sort/InsertionSort.java) | `O(n^2)`     | `O(n)`       | `O(n^2)`     | `O(1)`     | `in-place`  | 稳定  |
| [冒泡排序](/src/main/java/sort/BubbleSort.java)    | `O(n^2)`     | `O(n)`       | `O(n^2)`     | `O(1)`     | `in-place`  | 稳定  |
| [选择排序](/src/main/java/sort/SelectionSort.java) | `O(n^2)`     | `O(n^2)`     | `O(n^2)`     | `O(1)`     | `in-place`  | 不稳定 |

## 4.2说明

- 排序方式：
  - `in-place`：占用常数内存
  - `out-place`：占用额外内存
- 稳定性：排序前后，值相同的元素，位置是否发生变化

## 4.3.[题目](algorithm-training/4.sort.md)

# 5.搜索算法

## 5.1.深度优先搜索：DFS

- 特点：总是优先遍历新节点
- 实现模型：
  - 栈：先进后出
  - 递归：
- 用途：
  - 检测环路
  - 状态记录
- 用法：
  - 主函数：
    - 遍历所有的搜索位置
    - 判断是否开始搜索
  - 辅函数：
    - 递归调用

### 5.1.1.[回溯法](/src/main/java/leetcode/sub0046/Demo01.java)

- 核心：采用试错的思想，分步的解决一个问题
- 原理：
  - 每执行一步，锁定当前状态；
  - 若成功，则继续执行下一步(`DFS 搜索`)；
  - 若失败，解锁，返回上一步，继续尝试另一种可能
  - 直到找出所有的可行结果
- 诀窍：
  - 按引用传递状态
  - 递归结束后，归还所有状态

## 5.2.广度优先搜索：BFS

## 5.3.[并查集](/src/main/java/search/UnionFind.java)

- 描述：
  - 一种数据结构
  - 并：合并
  - 查：查找
  - 集：一个字典，存储的内容 `节点 => 父节点`
- 操作：
  - 新增：增加一个新的集合（只拥有一个节点）
  - 查找：查找某个节点属于哪个集合
    - 返回根节点
  - 合并：合并两个有关联的节点

- 使用场景：
  - 不交集森林
  - 连通分量

## 5.4.[题目](algorithm-training/5.first_search.md)
